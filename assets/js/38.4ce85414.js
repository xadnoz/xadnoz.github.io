(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{391:function(e,t,a){"use strict";a.r(t);var o=a(42),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"design-of-api-contexts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design-of-api-contexts"}},[e._v("#")]),e._v(" Design of API contexts")]),e._v(" "),a("p",[e._v("This design doc describes the Context class that is new in 0.13.")]),e._v(" "),a("h2",{attrs:{id:"goals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#goals"}},[e._v("#")]),e._v(" Goals")]),e._v(" "),a("ul",[a("li",[e._v("To centralise various bits of configuration that are presently duplicated throughout the API, such as directories for\nstoring files, the depth at which a tx is considered un-reorgable, the chosen network parameters and so on.")]),e._v(" "),a("li",[e._v("To simplify bitcoinj programming in future.")]),e._v(" "),a("li",[e._v("To avoid the temptation to overload NetworkParameters with tweakable bits and pieces of misc configuration.")]),e._v(" "),a("li",[e._v("Unblock various bits of API evolution that are currently made difficult by the desire to avoid too many source code\nchanges by developers.")])]),e._v(" "),a("h2",{attrs:{id:"background"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),a("p",[e._v('Since the very first version bitcoinj has had the concept of "network parameters": a class that wrapped various\nconstants and magic numbers that distinguish the Bitcoin main network from the test network, and later, from settings\nmeant only for unit tests and local regression testing.')]),e._v(" "),a("p",[e._v("However unlike many APIs, we have never had a more general notion of context and as the library has grown we have\nended up with an often confusing mishmash of duplicate settings and odd dependencies between objects. For example\nseveral parts of the library want to throw away data once a transaction is confirmed enough that we don't expect it\nto ever be re-orgd out of the chain, but there's no agreement on how deep that should be. The Wallet stores files, as\ndoes the block store, as does Orchid (Tor support), but each component must be told where to put this data individually.\nThe problem gets worse on Android, where there are no JAR files and data must be shipped as external files. On this\nplatform components that want to load data files must be configured with a path to their files individually and\nthere's no central list of what components need this.")]),e._v(" "),a("p",[e._v("Another problem is that in a few places, we have APIs that are in wide usage but need to start accepting an explicit\ncomponent to allow the underlying code to evolve. Top of the list is TransactionConfidence. Consider\nTransactionConfidence.getDepthInBlocks(). This method takes no parameters and thus practically requires that the\nconfidence object for every transaction in a wallet be touched on every single block in order to update its internal\ncounter. A better approach would be for it to just record the height it appeared at and then take an AbstractBlockChain\nas a parameter (and/or explicit height) then do the subtraction. But often this method is called in places far away\nfrom the last reference to a block chain and so this will be a painful API change. Ideally we could spread it out over\na release or two, to give developers time to update their code.")]),e._v(" "),a("p",[e._v("An even bigger issue is Transaction.getConfidence() itself. We would like to rewrite the Wallet so it no longer stores\nTransaction objects at all. But this would be a major API break, because apps often want to know about the confidence\nof a transaction and currently the only way to obtain this is via the getConfidence() method. The TxConfidenceTable class\n(renamed from MemoryPool) acts as a global map of txhash to confidence object, but we can't adjust the prototype of\nTransaction.getConfidence() to take one without breaking lots of code.")]),e._v(" "),a("p",[e._v("This proliferation of global variables makes it harder for developers to use multiple instances of bitcoinj\nsimultaneously, for example, to do cross-chain trading of different cryptocurrencies against each other.")]),e._v(" "),a("p",[e._v("Finally, several bitcoinj objects currently need to be plugged together in ways that aren't always obvious for full\nfunctionality to work. The constructors try to guide the developer but it's still a common source of mistakes.")]),e._v(" "),a("p",[e._v("We can resolve these problems by introducing a notion of a global Context object, used in the same places and ways as\nNetworkParameters is today.")]),e._v(" "),a("h2",{attrs:{id:"context-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context-object"}},[e._v("#")]),e._v(" Context object")]),e._v(" "),a("p",[e._v("The Context class is very simple. It is an immutable class that simply holds configuration data and references to other\nobjects. For now, we do not allow on-the-fly reconfiguration of the data stored within it. This is to simplify the\nimplementation code.")]),e._v(" "),a("h2",{attrs:{id:"alternatives-considered"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alternatives-considered"}},[e._v("#")]),e._v(" Alternatives considered")]),e._v(" "),a("p",[e._v('Some code bases, when faced with similar problems to the above, use a dependency injection container. These pieces\nof software effectively replace the "new" keyword and handle all object creation themselves, then wire objects together\nbased on annotations and centralised, explicit configuration.')]),e._v(" "),a("p",[e._v("Dependency injection would seem to be an attractive solution, but:")]),e._v(" "),a("ul",[a("li",[e._v("Experience of using Guice inside Google leads me to believe it will result in confusing code that breaks IDE navigation\nfeatures and is hostile to the inexperienced code reader.")]),e._v(" "),a("li",[e._v("Guice effectively changes the Java language and that makes it harder for people to contribute. There may be DI\nframeworks that are less aggressive, but I don't know of any.")]),e._v(" "),a("li",[e._v("DI often relies heavily on reflection and even runtime code synthesis, which we wish to avoid for performance reasons\nand to avoid complicating ProGuard configuration and transpilation.")]),e._v(" "),a("li",[e._v("DI is effectively just a complicated and indirect means of having a global context object: doing it directly makes the\ncode clearer and avoids the need for developers to learn new things.")])]),e._v(" "),a("h2",{attrs:{id:"transition-plan"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transition-plan"}},[e._v("#")]),e._v(" Transition plan")]),e._v(" "),a("p",[e._v("NetworkParameters appears everywhere in the bitcoinj API, and so introducing Context will have a major impact on it\nas well. We aim to keep API churn under control, to avoid losing developers across difficult upgrades. As such,\nContext will be phased in gradually over one or two releases.")]),e._v(" "),a("p",[e._v("We will follow these stages:")]),e._v(" "),a("ol",[a("li",[e._v('Context starts out by wrapping NetworkParameters, TxConfidenceTable and the "event horizon" (the number of blocks\nafter which we assume re-orgs cannot happen).')]),e._v(" "),a("li",[e._v("The construction of a Context object puts a reference to itself into a thread local storage slot. A static method\nis provided which retrieves this, as well as another that either retrieves "),a("em",[e._v("or creates")]),e._v(" a new Context. This second\nmethod is placed in the constructors of key classes like the Wallet or the block chain, and provides backwards\ncompatibility for developers. A log message is printed advising developers to update their code to create a Context\nthemselves. Attempting to use two instances of the library with different objects or NetworkParameters from the same\nthread may have complications or not work properly during this stage.")]),e._v(" "),a("li",[e._v("Classes that currently take NetworkParameters are augmented with new constructors that take Contexts instead. The\nold c'tors simply check the NetworkParameters they are given matches the Context's own view and then call into the\nnew c'tors. An exception is thrown if they don't match.")]),e._v(" "),a("li",[e._v("Release notes describe how to set a context and propagate it between threads. Developers can start migration in the\n0.13 release.")]),e._v(" "),a("li",[e._v("Internally, we start passing contexts through to objects that want one explicitly rather than relying on the thread\nlocal storage slot.")]),e._v(" "),a("li",[e._v("We mark constructors that take NetworkParameters as deprecated with the javadocs changing to point devs to the\nContext-taking equivalents.")]),e._v(" "),a("li",[e._v("In some future release, the deprecated methods are eventually removed, along with the Context thread local storage\nslot and automated cross-thread propagation magic.")])]),e._v(" "),a("p",[e._v("In parallel, global configuration will keep being moved into the Context class to make it more useful.")])])}),[],!1,null,null,null);t.default=n.exports}}]);