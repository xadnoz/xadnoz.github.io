(window.webpackJsonp=window.webpackJsonp||[]).push([[437],{837:function(a,t,e){"use strict";e.r(t);var r=e(42),o=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("Polkadot and Kusama make all stakers claim their rewards for past eras by submitting a transaction. This naturally leads to spreading out reward distribution, as people make transactions at disparate times, rather than updating the accounts of all stakers in a single block. Even if everyone submitted a reward claim at the same time, the fact that they are individual transactions would allow the block construction algorithm to process only a limited number per block and ensure that the network maintains a constant block time. If all rewards were sent out in one block, this could cause serious issues with the stability of the network.")]),a._v(" "),e("p",[a._v("Lazy payouts requires one transaction per staker per era to claim rewards, where a staker can be either a validator or a nominator. The reason Polkadot requires this is to avoid an attack where someone has several thousand accounts nominating a single validator. The major cost in reward distribution is mutating the accounts in storage, and Polkadot cannot pay out several thousand accounts in a single transaction.")]),a._v(" "),e("h2",{attrs:{id:"claiming-rewards"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#claiming-rewards"}},[a._v("#")]),a._v(" Claiming Rewards")]),a._v(" "),e("p",[a._v("Polkadot stores up to 84 eras of reward info like maps of era number to validator points, inflationary rewards, and nomination exposures.")]),a._v(" "),e("p",[a._v("Rewards will not be claimable more than 84 eras after they were earned. This means that all stakers --- nominators and validators alike --- must claim their rewards within 84 eras, or they will not be able to be claimed.")]),a._v(" "),e("h3",{attrs:{id:"validators"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#validators"}},[a._v("#")]),a._v(" Validators")]),a._v(" "),e("p",[a._v("In order to claim rewards, validators must submit a "),e("code",[a._v("payout_validator(era: EraIndex)")]),a._v(" transaction from their "),e("strong",[a._v("controller")]),a._v(" key, where "),e("code",[a._v("era")]),a._v(" is the era for which they are claiming rewards.")]),a._v(" "),e("h3",{attrs:{id:"nominators"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nominators"}},[a._v("#")]),a._v(" Nominators")]),a._v(" "),e("p",[a._v("Nominators will need to submit a "),e("code",[a._v("payout_nominator(era: EraIndex, validators: Vec<(T::AccountId, u32)>)")]),a._v(" transaction from their "),e("strong",[a._v("controller")]),a._v(" key, where:")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("era")]),a._v(" is the era for which that the nominator is claiming rewards.")]),a._v(" "),e("li",[e("code",[a._v("validators")]),a._v(" is a list of tuples of:\n"),e("ul",[e("li",[a._v("Validator stash account IDs that the nominator was nominating during "),e("code",[a._v("era")]),a._v(", and")]),a._v(" "),e("li",[a._v("The nominator's index in the list of nominators for that validator for that era.")])])])]),a._v(" "),e("p",[a._v("Providing the index eliminates search and allows for a lower transaction fee.")]),a._v(" "),e("p",[a._v("These details are handled for you automatically if you use the "),e("a",{attrs:{href:"https://polkadot.js.org/apps/#/staking/actions",target:"_blank",rel:"noopener noreferrer"}},[a._v("polkadot.js UI"),e("OutboundLink")],1),a._v(".")]),a._v(" "),e("h2",{attrs:{id:"f-a-q-and-cautionary-notes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#f-a-q-and-cautionary-notes"}},[a._v("#")]),a._v(" F.A.Q. and Cautionary Notes")]),a._v(" "),e("ol",[e("li",[e("strong",[a._v("Caution:")]),a._v(" Once a user claims rewards for an era, all reward information for that user for previous eras is removed. Regular users should not construct these transactions themselves, but should use a wallet or front end that safely claims in the correct order.")]),a._v(" "),e("li",[a._v("Rewards expire after 84 eras. On Polkadot, that's about 84 days. On Kusama, it is approximately 21 days.")]),a._v(" "),e("li",[a._v("Users must use their "),e("strong",[a._v("controller")]),a._v(" key to claim payouts. The "),e("strong",[a._v("stash")]),a._v(" key should remain in cold storage.")]),a._v(" "),e("li",[a._v("Claiming rewards (or neglecting to claim rewards) does not affect nominations in any way. Nominations will persist after claiming rewards or the rewards expire.")]),a._v(" "),e("li",[a._v("Polkadot provides a "),e("code",[a._v("batch")]),a._v(" function under the Utility pallet that allows the user to batch several transactions into a single transaction "),e("em",[a._v("from the same origin.")]),a._v(" Therefore, users can use this function to claim rewards for several eras for a single validator or nominator.")]),a._v(" "),e("li",[a._v('Rewards are not minted until they are claimed. Therefore, if your reward destination is "stash, increasing amount at stake", then your staked amount does not reflect your rewards until you claim them. If you want to maximize compounding, then you will need to claim often.')])]),a._v(" "),e("h2",{attrs:{id:"future-plans"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#future-plans"}},[a._v("#")]),a._v(" Future Plans")]),a._v(" "),e("p",[a._v("This scheme protects against malicious nominators, but is difficult for UX and especially hurts smaller nominators who would rather be passive participants and for whom the transaction fee could represent a non-trivial fraction of their rewards. We are actively investigating other solutions that would, for example, let a single user trigger the payout for all nominators of a single validator as long as that user is willing to pay the transaction fee.")])])}),[],!1,null,null,null);t.default=o.exports}}]);